#!/usr/bin/env python

from colorama import Fore, Style
from collections import namedtuple

import soidlib

import os
import os.path
import sys
import argparse
import subprocess
import importlib
import types
import functools

import z3
import pycvc5



class Oracle():

    def __init__( self ):

        self.runners = {
            soidlib.verification              : self.verif,
            soidlib.counterfactual.single     : self.ocf,
            soidlib.counterfactual.necessary  : self.ncf,
            soidlib.counterfactual.sufficient : self.scf,
            #soidlib.behavior.necessary        : self.nbv,
            #soidlib.behavior.sufficient       : self.sbv,
            #soidlib.agent                     : self.agent
        }

        self.ct  = 0
        self.introduction = ''

        self.reset()
        return


    def ld_env( self, query ):

        ret = None
        if hasattr( query, '_Soid__environmental' ):
            ret = query._Soid__environmental( self.E )

        def __inner( obs = False ):
            if type( ret ) == tuple and len( ret ) == 2:
                return ret[ 0 ] if not obs else ret[ 1 ]
            elif type( ret ) == tuple:
                pass # todo: handle
            else:
                return ret

        self.phi     = lambda: __inner()
        self.obs_phi = lambda: __inner( True )
        return


    def ld_st( self, query ):

        ret = None
        if hasattr( query, '_Soid__state' ):
            ret = query._Soid__state( self.S )

        def __inner( obs = False ):
            if type( ret ) == tuple and len( ret ) == 2:
                return ret[ 0 ] if not obs else ret[ 1 ]
            elif type( ret ) == tuple:
                pass # todo: handle
            else:
                return ret

        self.vphi     = lambda: __inner()
        self.obs_vphi = lambda: __inner( True )
        return


    def ld_bhv( self, query ):

        ret = None
        if hasattr( query, '_Soid__behavior' ):
            info = query._Soid__behavior_info

            if info.args == [ 'P' ]:
                ret = query._Soid__behavior( self.P )
            elif info.args == [ 'E', 'P' ]:
                ret = query._Soid__behavior( self.E, self.P )
            elif info.args == [ 'S', 'P' ]:
                ret = query._Soid__behavior( self.S, self.P )
            elif info.args == [ 'E', 'S', 'P' ]:
                ret = query._Soid__behavior( self.E, self.S, self.P )
            else:
                pass # todo: handle

        def __inner():
            return ret
        self.beta = __inner
        return


    def ld_agnt( self, makefile ):
        mdir, _ = os.path.split( makefile )

        # todo: tie in symbolize

        ret = subprocess.run( [ 'make', 'symbolic' ], cwd = mdir )
        klee_last = mdir + '/klee-last'

        i  = 1
        fs = []
        while True:
            fn = klee_last + '/test' + str( i ).zfill( 6 ) + '.smt2'
            if not os.path.isfile( fn ):
                break

            fs.append( fn )
            i += 1

        paths = [ z3.parse_smt2_file( f )[ 0 ] for f in fs ]

        ret = subprocess.run( [ 'make', 'clean' ], cwd = mdir )

        self.paths = paths
        return


    def build_pi( self ):

        symbls  = [ soidlib.types.util.bv32arr( '__soid__' + str( p ) ) for p in self.P ]
        amends  = [ soidlib.types.util.bv32arr_to_bv32( p ) == soidlib.types.util.bv32arr_to_bv32( symbls[ i ] ) for i, p in enumerate( self.P ) ]

        amended = [ z3.And( [ path ] + amends ) for path in self.paths ]

        def __inner():
            return z3.Or( *amended )
        self.pi = __inner
        return


    def load( self, query ):

        self.ct += 1
        self.reset()

        # register as oracle for query
        query._Soid__oracle( self )

        # extract mangled
        self.name   = query.query_name
        self.type   = query.query_type
        self.synth  = ( self.type not in [ soidlib.verification, soidlib.counterfactual.single ] )
        self.solver = z3.Solver() if not self.synth else pycvc5.Solver()

        query._Soid__declare()
        self.description = query._Soid__descriptor()

        self.ld_env( query )
        self.ld_st( query )
        self.ld_bhv( query )

        self.build_pi()

        return


    def reset( self ):

        self.synth  = None
        self.solver = None

        self.E = None    # environmental vars
        self.S = None    # state vars
        self.P = None    # program vars

        self.phi  = None # environmental
        self.vphi = None # state
        self.pi   = None
        self.beta = None # behavior

        # observed, optional for pretty printing counterfactuals
        self.obs_phi  = None # environmental
        self.obs_vphi = None # state

        self.description = None

        return


    def recurse( self, expr, I ):
        cs = []
        for child in expr.children():
            c, I = self.z3_to_cvc5( child, I )
            cs.append( c )

        return cs, I


    def z3_to_cvc5( self, expr, I = {} ):

        if expr == None:
            return None, I

        s = str( expr )
        if s in I:
            return I[ s ], I

        if z3.is_and( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.And, *cs ), I

        if z3.is_or( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Or, *cs ), I

        if z3.is_implies( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Implies, *cs ), I

        if z3.is_not( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Not, *cs ), I

        if z3.is_eq( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Equal, *cs ), I

        if z3.is_quantifier( expr ) and expr.is_exists():
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Exists, *cs ), I

        if z3.is_quantifier( expr ) and expr.is_forall():
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Forall, *cs ), I

        if z3.is_add( expr ):
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVAdd, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPAdd, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.Plus, *cs ), I

        if z3.is_mul( expr ):
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVMult, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPMult, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.Mult, *cs ), I

        if z3.is_sub( expr ):
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSub, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSub, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.Minus, *cs ), I

        if z3.is_div( expr ):
            pass

        if z3.is_idiv( expr ):
            pass

        if z3.is_mod( expr ):
            pass

        # signed le
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == '<=':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSle, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSle, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.LEQ, *cs ), I

        # unsigned le
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'ULE':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUle, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUle, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.LEQ, *cs ), I

        # signed lt
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == '<':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSlt, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSlt, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.LT, *cs ), I

        # unsigned lt
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'ULT':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUlt, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUlt, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.LT, *cs ), I

        # signed ge
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == '>=':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSge, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSge, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.GEQ, *cs ), I

        # unsigned ge
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'UGE':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUge, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUge, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.GEQ, *cs ), I

        # signed gt
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == '>':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSgt, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSgt, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.GT, *cs ), I

        # unsigned gt
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'UGT':
            cs, I = self.recurse( expr, I )

            c = expr.children()[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUgt, *cs ), I
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUgt, *cs ), I
            else:
                return self.solver.mkTerm( pycvc5.kinds.GT, *cs ), I

        # bitvector ops
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'Extract':
            c, I = self.z3_to_cvc5( expr.children()[ 0 ], I )
            ex = self.solver.mkOp( pycvc5.kinds.BVExtract, expr.params()[ 0 ], expr.params()[ 1 ] )
            return self.solver.mkTerm( ex, c ), I

        # bitvector ops
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'ZeroExt':
            c, I = self.z3_to_cvc5( expr.children()[ 0 ], I )
            ex = self.solver.mkOp( pycvc5.kinds.BVZeroExtend, expr.params()[ 0 ] )
            return self.solver.mkTerm( ex, c ), I

        # bitvector ops
        if hasattr( expr, 'decl' ) and str( expr.decl() ) == 'Concat':
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.BVConcat, *cs ), I

        if z3.is_select( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Select, *cs ), I

        if z3.is_store( expr ):
            cs, I = self.recurse( expr, I )
            return self.solver.mkTerm( pycvc5.kinds.Store, *cs ), I

        if z3.is_seq( expr ):
            pass

        # CONSTS

        if z3.is_true( expr ):
            return self.solver.mkTrue(), I

        if z3.is_false( expr ):
            return self.solver.mkFalse(), I

        if z3.is_int_value( expr ):
            return self.solver.mkInteger( expr.as_long() ), I

        if z3.is_rational_value( expr ):
            return self.solver.mkReal( expr.as_double() ), I

        if z3.is_algebraic_value( expr ):
            return self.solver.mkReal( expr.as_double() ), I

        if z3.is_bv_value( expr ):
            return self.solver.mkBitVector( expr.size(), expr.as_long() ), I

        if z3.is_finite_domain_value( expr ):
            pass

        if z3.is_fprm_value( expr ):
            pass

        if z3.is_fp_value( expr ):
            pass

        if z3.is_string_value( expr ):
            pass

        if z3.is_const_array( expr ) or z3.is_K( expr ):
            pass

        # VARS

        if z3.is_bool( expr ):
            v = self.solver.mkVar( self.solver.getBooleanSort(), str( expr ) )
            I[ s ] = v
            return v, I

        if z3.is_int( expr ):
            v = self.solver.mkVar( self.solver.getIntegerSort(), str( expr ) )
            I[ s ] = v
            return v, I

        if z3.is_real( expr ):
            v = self.solver.mkVar( self.solver.getRealSort(), str( expr ) )
            I[ s ] = v
            return v, I

        if z3.is_array( expr ):
            d, I = self.z3_to_cvc5( expr.domain(), I )
            r, I = self.z3_to_cvc5( expr.range(), I )
            v = self.solver.mkVar( self.solver.mkArraySort( d, r ), str( expr ) )
            I[ s ] = v
            return v, I

        if z3.is_map( expr ):
            pass

        if z3.is_bv( expr ):
            v = self.solver.mkVar( self.solver.mkBitVectorSort( expr.size() ), str( expr ) )
            I[ s ] = v
            return v, I

        if z3.is_finite_domain( expr ):
            pass

        if z3.is_fprm( expr ):
            pass

        if z3.is_fp( expr ):
            pass

        if z3.is_string( expr ):
            pass

        # SORTS

        if z3.is_arith_sort( expr ):
            if expr.is_int():
                return self.solver.getIntegerSort(), I
            elif expr.is_real():
                return self.solver.getRealSort(), I
            else:
                pass # todo: handle

        if z3.is_bv_sort( expr ):
            return self.solver.mkBitVectorSort( expr.size() ), I

        if z3.is_array_sort( expr ):
            d, I = self.z3_to_cvc5( expr.domain(), I )
            r, I = self.z3_to_cvc5( expr.range(), I )
            return self.solver.mkArraySort( d, r ), I

        if z3.is_finite_domain_sort( expr ):
            pass

        if z3.is_fp_sort( expr ):
            pass

        if z3.is_fprm_sort( expr ):
            pass


    def prep_sygus( self, I ):

        # set options
        self.solver.setOption( 'lang', 'sygus2' )
        self.solver.setOption( 'incremental', 'false' )
        self.solver.setOption( 'verbose', 'true' )
        self.solver.setOption( 'verbosity', '2' )
        #self.solver.setOption( 'trace', 'datatypes-check' )
        #self.solver.setOption( 'trace', 'datatypes-proc' )
        #self.solver.setOption( 'trace', 'datatypes-prereg' )
        #self.solver.setOption( 'trace', 'datatypes-debug' )
        #self.solver.setOption( 'trace', 'dt-expand' )
        #self.solver.setOption( 'trace', 'cegqi' )
        #self.solver.setOption( 'trace', 'cegqi-debug' )
        #self.solver.setOption( 'trace', 'cegqi-dt-debug' )

        # set logic
        self.solver.setLogic( 'AUFBV' )

        # add all input vars not in formulas to sygus context
        for v in self.E._fields:
            if v in I:
                continue
            _, I = self.z3_to_cvc5( getattr( self.E, v ) )

        for v in self.S._fields:
            if v in I:
                continue
            _, I = self.z3_to_cvc5( getattr( self.S, v ) )

        # define grammar terminals
        gbool = self.solver.mkVar( self.solver.getBooleanSort(), "Bool" )
        gbv32 = self.solver.mkVar( self.solver.mkBitVectorSort( 32 ), "BV32" )
        gbv24 = self.solver.mkVar( self.solver.mkBitVectorSort( 24 ), "BV24" )
        gbv16 = self.solver.mkVar( self.solver.mkBitVectorSort( 16 ), "BV16" )
        gbv08 = self.solver.mkVar( self.solver.mkBitVectorSort(  8 ), "BV08" )
        gbv01 = self.solver.mkVar( self.solver.mkBitVectorSort(  1 ), "BV01" )

        # make grammar, note that gbool needs to be there as the starting non-terminal
        g = self.solver.mkSygusGrammar( list( I.values() ), [ gbool, gbv32, gbv24, gbv16, gbv08, gbv01 ] )

        # define bitvector rules
        BV32Add = self.solver.mkTerm( pycvc5.kinds.BVAdd,  gbv32, gbv32 )
        BV32Mul = self.solver.mkTerm( pycvc5.kinds.BVMult, gbv32, gbv32 )
        BV32Sub = self.solver.mkTerm( pycvc5.kinds.BVSub,  gbv32, gbv32 )
        BV08Add = self.solver.mkTerm( pycvc5.kinds.BVAdd,  gbv08, gbv08 )
        BV08Mul = self.solver.mkTerm( pycvc5.kinds.BVMult, gbv08, gbv08 )
        BV08Sub = self.solver.mkTerm( pycvc5.kinds.BVSub,  gbv08, gbv08 )

        BV01Extract  = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVExtract,  0,  0 ), gbv08 )
        BV08Extract0 = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVExtract,  7,  0 ), gbv32 )
        BV08Extract1 = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVExtract, 15,  8 ), gbv32 )
        BV08Extract2 = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVExtract, 23, 16 ), gbv32 )
        BV08Extract3 = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVExtract, 31, 24 ), gbv32 )
        BV08ZeroExt  = self.solver.mkTerm( self.solver.mkOp( pycvc5.kinds.BVZeroExtend, 7 ), gbv01 )

        BV16Concat = self.solver.mkTerm( pycvc5.kinds.BVConcat, gbv08, gbv08 )
        BV24Concat = self.solver.mkTerm( pycvc5.kinds.BVConcat, gbv16, gbv08 )
        BV32Concat = self.solver.mkTerm( pycvc5.kinds.BVConcat, gbv24, gbv08 )

        g.addRules( gbv32, { BV32Add, BV32Mul, BV32Sub, BV32Concat } )
        g.addRules( gbv24, { BV24Concat } )
        g.addRules( gbv16, { BV16Concat } )
        g.addRules( gbv08, { BV08Add, BV08Mul, BV08Sub, BV08Extract0, BV08Extract1, BV08Extract2, BV08Extract3, BV08ZeroExt } )
        for val in I.values():
            g.addRules( gbv08, { self.solver.mkTerm( pycvc5.kinds.Select, val, gbv32 ) } )

        # define bitvector constants
        g.addRules( gbv32, { self.solver.mkBitVector( 32, 0 ) } )
        for i in range( 32 ):
            g.addRules( gbv32, { self.solver.mkBitVector( 32, ( 1 << i ) ) } )

        g.addRules( gbv01, { self.solver.mkBitVector( 1, 0 ) } )
        g.addRules( gbv01, { self.solver.mkBitVector( 1, 1 ) } )

        # define boolean rules
        And     = self.solver.mkTerm( pycvc5.kinds.And, gbool, gbool )
        Or      = self.solver.mkTerm( pycvc5.kinds.Or,  gbool, gbool )
        Not     = self.solver.mkTerm( pycvc5.kinds.Not, gbool )
        Implies = self.solver.mkTerm( pycvc5.kinds.Implies, gbool, gbool )
        _True   = self.solver.mkTrue()
        _False  = self.solver.mkFalse()

        BV32Sle  = self.solver.mkTerm( pycvc5.kinds.BVSle, gbv32, gbv32 )
        BV32Ule  = self.solver.mkTerm( pycvc5.kinds.BVUle, gbv32, gbv32 )
        BV32Slt  = self.solver.mkTerm( pycvc5.kinds.BVSlt, gbv32, gbv32 )
        BV32Ult  = self.solver.mkTerm( pycvc5.kinds.BVUlt, gbv32, gbv32 )
        BV32Sge  = self.solver.mkTerm( pycvc5.kinds.BVSge, gbv32, gbv32 )
        BV32Uge  = self.solver.mkTerm( pycvc5.kinds.BVUge, gbv32, gbv32 )
        BV32Sgt  = self.solver.mkTerm( pycvc5.kinds.BVSgt, gbv32, gbv32 )
        BV32Ugt  = self.solver.mkTerm( pycvc5.kinds.BVUgt, gbv32, gbv32 )
        BV08Sle  = self.solver.mkTerm( pycvc5.kinds.BVSle, gbv08, gbv08 )
        BV08Ule  = self.solver.mkTerm( pycvc5.kinds.BVUle, gbv08, gbv08 )
        BV08Slt  = self.solver.mkTerm( pycvc5.kinds.BVSlt, gbv08, gbv08 )
        BV08Ult  = self.solver.mkTerm( pycvc5.kinds.BVUlt, gbv08, gbv08 )
        BV08Sge  = self.solver.mkTerm( pycvc5.kinds.BVSge, gbv08, gbv08 )
        BV08Uge  = self.solver.mkTerm( pycvc5.kinds.BVUge, gbv08, gbv08 )
        BV08Sgt  = self.solver.mkTerm( pycvc5.kinds.BVSgt, gbv08, gbv08 )
        BV08Ugt  = self.solver.mkTerm( pycvc5.kinds.BVUgt, gbv08, gbv08 )

        g.addRules( gbool, { And, Or, Not, Implies, _True, _False,
                             BV32Sle, BV32Ule, BV32Slt, BV32Ult, BV32Sge, BV32Uge, BV32Sgt, BV32Ugt,
                             BV08Sle, BV08Ule, BV08Slt, BV08Ult, BV08Sge, BV08Uge, BV08Sgt, BV08Ugt } )

        return g


    # todo: either get beautifHOL working or reimplement it in Python
    def query_pp( self, name, query ):

        if isinstance( query, bool ):
            formula = soidlib.symbols.true if query else soidlib.symbols.false
        else:
            formula = query.soid_pp

        if name == 'phi':
            print( f'\n\t                 environmental ({soidlib.symbols.phi}). {formula}' )
        elif name == 'vphi':
            print( f'\n\t                         state ({soidlib.symbols.vphi}). {formula}' )
        elif name == 'beta':
            print( f'\n\t                      behavior ({soidlib.symbols.beta}). {formula}' )

        return


    def model_recurse( self, expr, tier = 3 ):

        # todo: make robust
        if z3.is_store( expr ) or z3.is_K( expr ):
            if len( expr.children() ) == 1 and isinstance( expr.children()[ 0 ], z3.BitVecNumRef ):
                    return expr.children()[ 0 ].as_long()

            if len( expr.children() ) == 3:
                if z3.is_K( expr.children()[ 0 ] ) and isinstance( expr.children()[ 2 ], z3.BitVecNumRef ):
                    return expr.children()[ 2 ].as_long()

                elif z3.is_store( expr.children()[ 0 ] ) and isinstance( expr.children()[ 2 ], z3.BitVecNumRef ):
                    return ( expr.children()[ 2 ].as_long() << tier ) + self.model_recurse( expr.children()[ 0 ], tier - 1 )


    def model_pp( self, model ):
        vs = [ d for d in model.decls() if '__soid__' not in d.name() ]
        nl = max( [ len( d.name() ) for d in vs ] )

        for v in vs:
            val   = self.model_recurse( model[ v ] )

            ref   = [ vr for vr in ( self.E + self.S + self.P ) if str( vr ) == v.name() ].pop()
            btype = ref.soid_base

            if btype == 'bool':
                val = soidlib.symbols.true if val == 1 else soidlib.symbols.false

            if btype == 'u32':
                val = str( val )

            name = v.name().rjust( nl )
            if hasattr( ref, 'soid_val_pp' ) and val in ref.soid_val_pp:
                val = ref.soid_val_pp[ val ]

            print( f'\n\t                 {name}. {val}' )

        exit()
        return


    # copied from https://github.com/cvc5/cvc5/blob/39f90ff035a5e5024fe0cd11b965f1103d83e88d/examples/api/python/utils.py
    def synthd_pp( self, terms, solutions ):

        def define_fun_to_string( f, params, body ):
            sort = f.getSort()
            if sort.isFunction():
                sort = f.getSort().getFunctionCodomainSort()
                result = ""
                result += "(define-fun " + str( f ) + " ("
                for param in params:
                    if i > 0:
                        result += " "
                    else:
                        result += "(" + str( param ) + " " + str( param.getSort() ) + ")"
            result += ") " + str( sort ) + " " + str( body ) + ")"
            return result


        result = ""
        for i, term in enumerate( terms ):
            params = []
            if solutions[ i ].getKind() == pycvc5.kinds.Lambda:
                params += solutions[ i ][ 0 ]
                body    = solutions[ i ][ 1 ]
            result += "  " + define_fun_to_string( term, params, body ) + "\n"
            print( result )

        return


    def run( self ):
        self.runners[ self.type ]()  # todo: handle error case


    def verif_pp( self, unsat, model = None ):
        mark  = chr(int('2713', 16)) if unsat else chr(int('2717', 16))
        color = Fore.GREEN if unsat else Fore.RED

        print(
            f'\n\t                                                                                                              '
            f'\n\t{str(self.ct).zfill(7)}.  |  name: {self.name}  |  type: verification                                         '
        )
        print( self.description )
        print(
            f'\n\t                result: [{color}{mark}{Style.RESET_ALL}]                                                      '
            f'\n\t                                                                                                              '
            f'\n\tconstraints:                                                                                                  '
            f'\n\t                                                                                                              '
        )

        self.query_pp( 'phi',  self.phi() )
        self.query_pp( 'vphi', self.vphi() )
        self.query_pp( 'beta', self.beta() )

        if not unsat and model:
            print(
                f'\n\t                                                                                                          '
                f'\n\tcounterexample:                                                                                           '
                f'\n\t                                                                                                          '
            )
            self.model_pp( model )

        print(
            f'\n\t                                                                                                              '
        )


    def verif( self ):
        self.solver.add(
            z3.Not(
                z3.Implies(
                    z3.And( self.phi(), self.vphi(), self.pi() ),
                    self.beta() ) ) )


        unsat = ( self.solver.check() == z3.unsat )
        if unsat:
            return self.verif_pp( unsat )

        model = self.solver.model()

        for var in list( self.E ) + list( self.S ) + list( self.P ):
            model.eval( var, model_completion = True )

        return self.verif_pp( unsat, model )


    def ocf( self ):
        self.solver.add(
            z3.And(
                z3.And( self.phi(), self.vphi(), self.pi() ),
                z3.Implies(
                    z3.And( self.phi(), self.vphi(), self.pi() ),
                    self.beta() ) ) )

        unsat = ( self.solver.check() == z3.unsat )
        if unsat:
            pass

        model = self.solver.model()

        for var in list( self.E ) + list( self.S ) + list( self.P ):
            model.eval( var, model_completion = True )


    def ncf( self ):

        phi,  I = self.z3_to_cvc5( self.phi() )
        vphi, I = self.z3_to_cvc5( self.vphi(), I )
        pi,   _ = self.z3_to_cvc5( self.pi() )
        beta, _ = self.z3_to_cvc5( self.beta() )

        if not phi:
            phi  = self.solver.mkTrue()

        if not vphi:
            vphi = self.solver.mkTrue()

        g = self.prep_sygus( I )

        # define target function
        nf = self.solver.synthFun( "necessary", list( I.values() ), self.solver.getBooleanSort(), g )

        # invoke as uninterpretated function for use with semantic constraint
        args = [ self.solver.mkSygusVar( i.getSort(), str( i ) ) for i in I.values() ]
        necc = self.solver.mkTerm( pycvc5.kinds.ApplyUf, nf, *args )

        self.solver.addSygusConstraint(
            self.solver.mkTerm( pycvc5.kinds.And,
                                self.solver.mkTerm( pycvc5.kinds.And, [ necc, phi, vphi, pi ] ),
                                self.solver.mkTerm( pycvc5.kinds.Implies,
                                                    self.solver.mkTerm( pycvc5.kinds.And, [ necc, phi, vphi, pi ] ),
                                                    beta ) ) )

        if ( self.solver.checkSynth().isUnsat() ):
            terms = [ nf ]
            self.synthd_pp( terms, self.solver.getSynthSolutions( terms ) )


    def scf( self ):
        pass



##########################
##### CLI FUNCTIONS ######
##########################



def parse_args():

    parser = argparse.ArgumentParser( description = 'SMT-based oracles for investigating decisions.' )

    parser.add_argument( '-f', '--float', action = 'store_true', default = False, dest = 'float', \
                         help = 'Use alternative symbolic execution (KLEE) engine with experimental support for floats.' )
    parser.add_argument( '-m', '--make', action = 'store', type = str, default = None, dest = 'make', required = True, \
                         help = 'Location of program makefile; if not a resolveable path soid will attempt to load ./Makefile.' )
    parser.add_argument( '-qs', '-queries', action = 'store', type = str, default = None, dest = 'queries', required = True, \
                         help = 'Location of queries directory; if not a resolveable path soid will attempt to use ./')
    parser.add_argument( '-n', '--enum', action = 'store', type = int, default = 100, dest = 'enum', required = False, \
                         help = 'Number of candidates to enumerate, used for sufficient synthesis queries.' )

    args = parser.parse_args()

    if not os.path.exists( args.make ):
        args.make  = './Makefile'
    if not os.path.exists( args.queries ):
        args.queries = './'

    return args


def extract( qs, args, oracle, queue = [] ):

    if 'Soid' not in dir( qs ) and 'soidlib' not in dir( qs ):
        return queue

    for name in dir( qs ):
        obj = getattr( qs, name )

        if callable( obj ) and name == 'introduction':
            oracle.introduction = obj()  # todo: handle error case

        if isinstance( obj, types.ModuleType ):
            queue = extract( obj, args, oracle, queue )

        if isinstance( obj, soidlib.Soid ):
            if not obj.skip:
                queue.append( obj )

    return queue



if __name__ == '__main__':

    oracle = Oracle()
    args = parse_args()

    # todo: rework once symbolize is done
    oracle.ld_agnt( args.make )

    path, fn = os.path.split( args.queries )
    sys.path.insert( 0, path )
    qs = importlib.import_module( fn )

    queries = extract( qs, args, oracle )
    queries.sort( key = lambda query: query.priority, reverse = True )

    print( oracle.introduction )

    while queries:
        nxt = queries.pop()
        oracle.load( nxt )
        oracle.run()
