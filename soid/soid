#!/usr/bin/env python

from queue import LifoQueue
from collections import namedtuple

import soidlib

import os
import os.path
import sys
import argparse
import subprocess
import importlib
import types
import functools

import z3
import pycvc5



class Oracle():

    def __init__( self ):

        self.runners = {
            soidlib.verification              : self.verif,
            #soidlib.counterfactual.single     : self.ocf,
            #soidlib.counterfactual.necessary  : self.ncf,
            #soidlib.counterfactual.sufficient : self.scf,
            #soidlib.behavior.necessary        : self.nbv,
            #soidlib.behavior.sufficient       : self.sbv,
            #soidlib.agent                     : self.agent
        }

        self.reset()
        return


    def ld_env( self, query ):
        def __inner():
            return query._Soid__environmental( self.E )
        self.phi = __inner
        return


    def ld_st( self, query ):
        def __inner():
            return query._Soid__state( self.S )
        self.vphi = __inner
        return


    def ld_bhv( self, query ):
        def __inner():
            info = query._Soid__behavior_info

            if info.args == [ 'P' ]:
                return query._Soid__behavior( self.P )
            elif info.args == [ 'E', 'P' ]:
                return query._Soid__behavior( self.E, self.P )
            elif info.args == [ 'S', 'P' ]:
                return query._Soid__behavior( self.S, self.P )
            elif info.args == [ 'E', 'S', 'P' ]:
                return query._Soid__behavior( self.E, self.S, self.P )
            else:
                pass # todo: handle
        self.beta = __inner
        return


    def ld_agnt( self, makefile ):
        mdir, _ = os.path.split( makefile )

        # todo: tie in symbolize

        ret = subprocess.run( [ 'make', 'symbolic' ], cwd = mdir )
        klee_last = mdir + '/klee-last'

        i  = 1
        fs = []
        while True:
            fn = klee_last + '/test' + str( i ).zfill( 6 ) + '.smt2'
            if not os.path.isfile( fn ):
                break

            fs.append( fn )
            i += 1

        paths = [ z3.parse_smt2_file( f )[ 0 ] for f in fs ]

        ret = subprocess.run( [ 'make', 'clean' ], cwd = mdir )

        self.paths = paths
        return


    def build_pi( self ):

        symbls  = [ soidlib.types.util.bv32arr( '__soid__' + str( p ) ) for p in self.P ]
        amends  = [ soidlib.types.util.bv32arr_to_bv32( p ) == soidlib.types.util.bv32arr_to_bv32( symbls[ i ] ) for i, p in enumerate( self.P ) ]

        amended = [ z3.And( [ path ] + amends ) for path in self.paths ]

        def __inner():
            return z3.Or( *amended )
        self.pi = __inner
        return


    def load( self, query ):

        self.reset()

        # register as oracle for query
        query._Soid__oracle( self )

        # extract mangled
        self.name   = query._Soid__name
        self.type   = query._Soid__type
        self.synth  = ( self.type not in [ soidlib.verification, soidlib.counterfactual.single ] )
        self.solver = z3.Solver() if not self.synth else pycvc5.Solver()

        query._Soid__declare()
        self.description = query._Soid__descriptor()

        self.ld_env( query )
        self.ld_st( query )
        self.ld_bhv( query )

        self.build_pi()

        return


    def reset( self ):

        self.synth  = None
        self.solver = None

        self.E = None    # environmental vars
        self.S = None    # state vars
        self.P = None    # program vars

        self.phi  = None # environmental
        self.vphi = None # state
        self.pi   = None
        self.beta = None # behavior

        # observed, optional for pretty printing counterfactuals
        self.obs_phi  = None # environmental
        self.obs_vphi = None # state

        self.description = None

        return


    def z3_to_cvc5( self, expr ):

        if z3.is_bool( expr ):
            return self.solver.mkVar( self.solver.getBooleanSort(), str( expr ) )

        if z3.is_true( expr ):
            return self.solver.mkTrue()

        if z3.is_false( expr ):
            return self.solver.mkFalse()

        if z3.is_and( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.And, c0, c1 )

        if z3.is_or( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Or, c0, c1 )

        if z3.is_implies( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Implies, c0, c1 )

        if z3.is_not( expr ):
            c0 = z3_to_cvc5( expr.children[ 0 ] )
            return self.solver.mkTerm( pycvc5.kinds.Not, c0 )

        if z3.is_eq( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Equal, c0, c1 )

        if z3.is_quantifier( expr ) and expr.is_exists():
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Exists, c0, c1 )

        if z3.is_quantifier( expr ) and expr.is_forall():
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Forall, c0, c1 )

        if z3.is_int( expr ):
            return self.solver.mkVar( self.solver.getIntegerSort(), str( expr ) )

        if z3.is_real( expr ):
            return self.solver.mkVar( self.solver.getRealSort(), str( expr ) )

        if z3.is_int_value( expr ):
            return self.solver.mkInteger( expr.as_long() )

        if z3.is_rational_value( expr ):
            return self.solver.mkReal( expr.as_double() )

        if z3.is_algebraic_value( expr ):
            return self.solver.mkReal( expr.as_double() )

        if z3.is_add( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVAdd, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPAdd, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.Plus, c0, c1  )

        if z3.is_mul( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVMult, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPMult, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.Mult, c0, c1  )

        if z3.is_sub( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSub, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSub, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.Minus, c0, c1  )

        if z3.is_div( expr ):
            pass

        if z3.is_idiv( expr ):
            pass

        if z3.is_mod( expr ):
            pass

        # signed le
        if str( expr.decl() ) == '<':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSle, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSle, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.LEQ, c0, c1  )

        # unsigned le
        if str( expr.decl() ) == 'ULE':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUle, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUle, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.LEQ, c0, c1  )

        # signed lt
        if str( expr.decl() ) == '<':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSlt, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSlt, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.LT, c0, c1  )

        # unsigned lt
        if str( expr.decl() ) == 'ULE':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUlt, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUlt, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.LT, c0, c1  )

        # signed ge
        if str( expr.decl() ) == '<':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSge, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSge, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.GEQ, c0, c1  )

        # unsigned ge
        if str( expr.decl() ) == 'ULE':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUge, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUge, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.GEQ, c0, c1  )

        # signed gt
        if str( expr.decl() ) == '<':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVSgt, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPSgt, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.GT, c0, c1  )

        # unsigned gt
        if str( expr.decl() ) == 'ULE':
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )

            c = expr.children[ 0 ]
            if z3.is_bv( c ) or z3.is_bv_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.BVUgt, c0, c1 )
            elif z3.is_fp( c ) or z3.is_fp_value( c ) or z3.is_fprm( c ) or z3.is_fprm_value( c ):
                return self.solver.mkTerm( pycvc5.kinds.FPUgt, c0, c1 )
            else:
                return self.solver.mkTerm( pycvc5.kinds.GT, c0, c1  )

        if z3.is_bv( expr ):
            return self.solver.mkVar( self.solver.mkBitVectorSort( expr.size() ), str( expr ) )

        if z3.is_bv_value( expr ):
            return self.solver.mkBitVec( expr.size() )

        if z3.is_array( expr ):
            return self.solver.mkTerm( pycvc5.kinds.Array, z3_to_cvc5( expr.domain() ), z3_to_cvc5( expr.range() ) )

        if z3.is_const_array( expr ):
            pass

        if z3.is_K( expr ):
            pass

        if z3.is_map( expr ):
            pass

        if z3.is_select( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Select, c0, c1 )

        if z3.is_store( expr ):
            c0, c1 = z3_to_cvc5( expr.children[ 0 ] ), z3_to_cvc5( expr.children[ 1 ] )
            return self.solver.mkTerm( pycvc5.kinds.Store, c0, c1 )

        if z3.is_finite_domain( expr ):
            pass

        if z3.is_finite_domain_value( expr ):
            pass

        if z3.is_fprm( expr ):
            pass

        if z3.is_fprm_value( expr ):
            pass

        if z3.is_fp( expr ):
            pass

        if z3.is_fp_value( expr ):
            pass

        if z3.is_seq( expr ):
            pass

        if z3.is_string( expr ):
            pass

        if z3.is_string_value( expr ):
            pass

        if z3.is_arith_sort( expr ):
            if expr.is_int():
                return self.solver.getIntegerSort()
            elif expr.is_real():
                return self.solver.getRealSort()
            else:
                pass # todo: handle

        if z3.is_bv_sort( expr ):
            return self.solver.mkBitVectorSort( expr.size() )

        if z3.is_array_sort( expr ):
            return self.solver.mkArraySort( z3_to_cvc5( expr.domain() ), z3_to_cvc5( expr.range() ) )

        if z3.is_finite_domain_sort( expr ):
            pass

        if z3.is_fp_sort( expr ):
            pass

        if z3.is_fprm_sort( expr ):
            pass


    def run( self ):
        self.runners[ self.type ]() # todo: handle error case


    def verif( self ):
        self.solver.add(
            z3.Not(
                z3.And(
                    z3.And( self.phi(), self.vphi(), self.pi() ),
                    z3.Implies(
                        z3.And( self.phi(), self.vphi(), self.pi() ),
                        self.beta() ) ) ) )

        unsat = ( self.solver.check() == z3.unsat )

        if not unsat:
            model = self.solver.model()

            for var in list( self.E ) + list( self.S ) + list( self.P ):
                model.eval( var, model_completion = True )


    def ocf( self ):
        self.solver.add(
            z3.And(
                z3.And( phi, vphi, pi ),
                z3.Implies(
                    z3.And( phi, vphi, pi ),
                    beta ) ) )

        unsat = ( self.solver.check() == z3.unsat )

        if not unsat:
            model = self.solver.model()

            for var in list( self.E ) + list( self.S ) + list( self.P ):
                model.eval( var, model_completion = True )



##########################
##### CLI FUNCTIONS ######
##########################



def parse_args():

    parser = argparse.ArgumentParser( description = 'SMT-based oracles for investigating decisions.' )

    parser.add_argument( '-f', '--float', action = 'store_true', default = False, dest = 'float', \
                         help = 'Use alternative symbolic execution (KLEE) engine with experimental support for floats.' )
    parser.add_argument( '-m', '--make', action = 'store', type = str, default = None, dest = 'make', required = True, \
                         help = 'Location of program makefile; if not a resolveable path soid will attempt to load ./Makefile.' )
    parser.add_argument( '-qs', '-queries', action = 'store', type = str, default = None, dest = 'queries', required = True, \
                         help = 'Location of queries directory; if not a resolveable path soid will attempt to use ./')
    parser.add_argument( '-q', '--query', action = 'store', type = str, default = None, nargs = '*', dest = 'query', required = False, \
                         help = 'List of queries from directory to execute; if this parameter is not provided then all are attempted.' )
    parser.add_argument( '-n', '--enum', action = 'store', type = int, default = 100, dest = 'enum', required = False, \
                         help = 'Number of candidates to enumerate, used for sufficient synthesis queries.' )

    args = parser.parse_args()

    if not os.path.exists( args.make ):
        args.make  = './Makefile'
    if not os.path.exists( args.queries ):
        args.query = './'

    return args



def extract( qs, args, queue = LifoQueue() ):

    if 'soidlib' not in dir( qs ):
        return queue

    for name in dir( qs ):
        obj = getattr( qs, name )

        if isinstance( obj, types.ModuleType ):
            queue = extract( obj, args, queue )

        if isinstance( obj, soidlib.Soid ):
            #todo: fix
            #if args.query and qs.__name__ not in args.query:
            #    continue
            queue.put( obj )

    return queue



if __name__ == '__main__':

    oracle = Oracle()
    args = parse_args()

    oracle.ld_agnt( args.make )

    path, fn = os.path.split( args.queries )
    sys.path.insert( 0, path )
    qs = importlib.import_module( fn )

    queries = extract( qs, args )

    while not queries.empty():
        nxt = queries.get()
        oracle.load( nxt )
        oracle.run()
