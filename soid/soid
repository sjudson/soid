#!/usr/bin/env python

from queue import LifoQueue
from collections import namedtuple

import soidlib

import os
import os.path
import sys
import argparse
import subprocess
import importlib
import types
import functools

import z3
import pycvc5




class Oracle():

    def __init__( self ):

        self.runners = {
            soidlib.verification              : self.verif,
            #soidlib.counterfactual.single     : self.ocf,
            #soidlib.counterfactual.necessary  : self.ncf,
            #soidlib.counterfactual.sufficient : self.scf,
            #soidlib.behavior.necessary        : self.nbv,
            #soidlib.behavior.sufficient       : self.sbv,
            #soidlib.agent                     : self.agent
        }

        self.reset()
        return


    def ld_env( self, query ):
        def __inner():
            return query._Soid__environmental( self.E )
        self.phi = __inner
        return


    def ld_st( self, query ):
        def __inner():
            return query._Soid__state( self.S )
        self.vphi = __inner
        return


    def ld_bhv( self, query ):
        def __inner():
            info = query._Soid__behavior_info

            if info.args == [ 'P' ]:
                return query._Soid__behavior( self.P )
            elif info.args == [ 'E', 'P' ]:
                return query._Soid__behavior( self.E, self.P )
            elif info.args == [ 'S', 'P' ]:
                return query._Soid__behavior( self.S, self.P )
            elif info.args == [ 'E', 'S', 'P' ]:
                return query._Soid__behavior( self.E, self.S, self.P )
            else:
                pass # todo: handle
        self.beta = __inner
        return


    def ld_agnt( self, makefile ):
        mdir, _ = os.path.split( makefile )

        # todo: tie in symbolize

        ret = subprocess.run( [ 'make', 'symbolic' ], cwd = mdir )
        klee_last = mdir + '/klee-last'

        i  = 1
        fs = []
        while True:
            fn = klee_last + '/test' + str( i ).zfill( 6 ) + '.smt2'
            if not os.path.isfile( fn ):
                break

            fs.append( fn )
            i += 1

        paths = [ z3.parse_smt2_file( f )[ 0 ] for f in fs ]

        ret = subprocess.run( [ 'make', 'clean' ], cwd = mdir )

        self.paths = paths
        return


    def build_pi( self ):

        symbls  = [ soidlib.types.util.bv32arr( '__soid__' +  p.__str__() ) for p in self.P ]
        amends  = [ soidlib.types.util.bv32arr_to_bv32( p ) == soidlib.types.util.bv32arr_to_bv32( symbls[ i ] ) for i, p in enumerate( self.P ) ]

        amended = [ z3.And( [ path ] + amends ) for path in self.paths ]

        def __inner():
            return z3.Or( *amended )
        self.pi = __inner
        return


    def load( self, query ):

        self.reset()

        # register as oracle for query
        query._Soid__oracle( self )

        # extract mangled
        self.name   = query._Soid__name
        self.type   = query._Soid__type
        self.synth  = ( self.type not in [ soidlib.verification, soidlib.counterfactual.single ] )
        self.solver = z3.Solver() if not self.synth else pycvc5.Solver()

        query._Soid__declare()
        self.description = query._Soid__descriptor()

        self.ld_env( query )
        self.ld_st( query )
        self.ld_bhv( query )

        self.build_pi()

        return


    def reset( self ):

        self.synth  = None
        self.solver = None

        self.E = None    # environmental vars
        self.S = None    # state vars
        self.P = None    # program vars

        self.phi  = None # environmental
        self.vphi = None # state
        self.pi   = None
        self.beta = None # behavior

        # observed, optional for pretty printing counterfactuals
        self.obs_phi  = None # environmental
        self.obs_vphi = None # state

        self.description = None

        return



    def z3_to_cvc5( expr ):
        pass


    def run( self ):
        self.runners[ self.type ]() # todo: handle error case


    def verif( self ):
        #print(self.phi())
        #print()
        #print(self.vphi())
        #print()
        #print(self.pi())
        #print()
        #print(self.beta())
        #print('\n\n')
        self.solver.add( z3.Not( z3.Implies( z3.And( self.phi(), self.vphi(), self.pi() ), self.beta() ) ) )
        unsat = ( self.solver.check() == z3.unsat )

        #print(unsat)
        #print('\n\n\n')

        if not unsat:
            model = self.solver.model()



##########################
##### CLI FUNCTIONS ######
##########################

            

def parse_args():

    parser = argparse.ArgumentParser( description = 'SMT-based oracles for investigating decisions.' )

    parser.add_argument( '-f', '--float', action = 'store_true', default = False, dest = 'float', \
                         help = 'Use alternative symbolic execution (KLEE) engine with experimental support for floats.' )
    parser.add_argument( '-m', '--make', action = 'store', type = str, default = None, dest = 'make', required = True, \
                         help = 'Location of program makefile; if not a resolveable path soid will attempt to load ./Makefile.' )
    parser.add_argument( '-qs', '-queries', action = 'store', type = str, default = None, dest = 'queries', required = True, \
                         help = 'Location of queries directory; if not a resolveable path soid will attempt to use ./')
    parser.add_argument( '-q', '--query', action = 'store', type = str, default = None, nargs = '*', dest = 'query', required = False, \
                         help = 'List of queries from directory to execute; if this parameter is not provided then all are attempted.' )
    parser.add_argument( '-n', '--enum', action = 'store', type = int, default = 100, dest = 'enum', required = False, \
                         help = 'Number of candidates to enumerate, used for sufficient synthesis queries.' )

    args = parser.parse_args()

    if not os.path.exists( args.make ):
        args.make  = './Makefile'
    if not os.path.exists( args.queries ):
        args.query = './'

    return args


def extract( qs, args, queue = LifoQueue() ):

    if 'soidlib' not in dir( qs ):
        return queue

    for name in dir( qs ):
        obj = getattr( qs, name )

        if isinstance( obj, types.ModuleType ):
            queue = extract( obj, args, queue )

        if isinstance( obj, soidlib.Soid ):
            #todo: fix
            #if args.query and qs.__name__ not in args.query:
            #    continue
            queue.put( obj )

    return queue


if __name__ == '__main__':

    oracle = Oracle()
    args = parse_args()

    oracle.ld_agnt( args.make )

    path, fn = os.path.split( args.queries )
    sys.path.insert( 0, path )
    qs = importlib.import_module( fn )

    queries = extract( qs, args )

    while not queries.empty():
        nxt = queries.get()
        oracle.load( nxt )
        oracle.run()
